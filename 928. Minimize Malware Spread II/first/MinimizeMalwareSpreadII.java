package first;

import java.util.*;
import java.util.stream.Collectors;

public class MinimizeMalwareSpreadII {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        Arrays.sort(initial);
        Set<Integer> initSet = new HashSet<>();
        initSet.addAll(Arrays.stream(initial).boxed().collect(Collectors.toList()));
        List<Integer>[] infectedBy = new List[graph.length];
        for (int i = 0; i < infectedBy.length; i++)
            infectedBy[i] = new ArrayList<>();
        // Run DFS of each infected node in initial
        // record nodes  will be infected by the infected node
        for (int infected : initial) {
            Set<Integer> infectedNodes = new HashSet<>();
            dfs(graph, infected, infectedNodes, initSet);
            for (int node : infectedNodes)
                infectedBy[node].add(infected);
        }
        int[] count = new int[graph.length];
        int max = Integer.MIN_VALUE;
        int removedNode = Integer.MAX_VALUE;
        for (int i = 0; i < infectedBy.length; i++) {
            if (infectedBy[i].size() != 1) continue;
            int initInfected = infectedBy[i].get(0);
            count[initInfected]++;
            if (count[initInfected] > max) {
                max = count[initInfected];
                removedNode = initInfected;
            }
            if (count[initInfected] == max)
                removedNode = Math.min(removedNode, initInfected);
        }
        return removedNode == Integer.MAX_VALUE ? initial[0] : removedNode;
    }

    private void dfs(int[][] graph, int infected, Set<Integer> infectedNodes, Set<Integer> initSet) {
        for (int i = 0; i < graph.length; i++) {
            if (graph[infected][i] == 1 && !infectedNodes.contains(i) && !initSet.contains(i)) {
                infectedNodes.add(i);
                dfs(graph, i, infectedNodes, initSet);
            }
        }
    }
}
