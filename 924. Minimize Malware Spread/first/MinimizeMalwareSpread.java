package first;

import java.util.*;
import java.util.stream.Collectors;

public class MinimizeMalwareSpread {
    public int minMalwareSpread(int[][] graph, int[] initial) {

        return minMalwareSpreadUN(graph, initial);
    }

    //--------------------------------------------------------
    // DFS solution
    //--------------------------------------------------------
    public int minMalwareSpreadDFS(int[][] graph, int[] initial) {
        if (graph.length == 0 || initial.length == 0) return 0;
        Set<Integer> infectedSet = new HashSet<>();
        infectedSet.addAll(Arrays.stream(initial).boxed().collect(Collectors.toList()));
        Arrays.sort(initial);

        int max = 0;
        int removedNode = -1;
        boolean[] visited = new boolean[graph.length];
        for (Integer i : initial) {
            if (visited[i]) continue;
            boolean moreThanTwoNodeInfected = false;
            visited[i] = true;
            Set<Integer> union = new HashSet<>();
            union.add(i);
            Stack<Integer> stack = new Stack<>();
            stack.push(i);
            while (!stack.isEmpty()) {
                int top = stack.pop();
                for (int j = i + 1; j < graph.length; j++) {
                    if (visited[j] || graph[top][j] == 0) continue;
                    if (infectedSet.contains(j)) moreThanTwoNodeInfected = true;
                    visited[j] = true;
                    union.add(j);
                    stack.push(j);
                }
            }
            if (union.size() > max && !moreThanTwoNodeInfected) {
                max = union.size();
                removedNode = i;
            }
        }

        return removedNode < 0 ? initial[0] : removedNode;
    }

    //--------------------------------------------------------
    // Union-Find solution
    //--------------------------------------------------------
    private int[] parent;
    private int[] nodeCount;

    private void union(int x, int y) {
        int parentX = find(x);
        parent[parentX] = find(y);
        nodeCount[parent[parentX]]++;
    }

    private int find(int x) {
        if (parent[x] != x)
            return find(parent[x]);
        return x;
    }

    private int minMalwareSpreadUN(int[][] graph, int[] initial) {
        if (graph.length == 0 || initial.length == 0) return 0;
        parent = new int[graph.length];
        nodeCount = new int[graph.length];
        Arrays.sort(initial);

        for (int i = 0; i < graph.length; i++) {
            parent[i] = i;
            for (int j = 0; j < i; j++)
                if (graph[i][j] == 1) union(i, j);
        }
        int[] infectedCount = new int[graph.length];
        for (Integer node : initial)
            infectedCount[find(node)]++;

        int max = -1;
        int removeNode = initial[0];
        for (Integer node : initial) {
            int parentNode = find(node);
            if (infectedCount[parentNode] == 1 && nodeCount[parentNode] > max) {
                removeNode = node;
                max = nodeCount[parentNode];
            }
        }

        return removeNode;
    }
}
